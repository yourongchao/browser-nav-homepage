# Firefox和trea浏览器本地文件存储功能实现方案

## 1. 问题分析

当前代码使用了`File System Access API`（包括`showSaveFilePicker`和`showOpenFilePicker`），但这些API仅支持Chrome、Edge和Opera等Chromium内核浏览器。Firefox和trea浏览器不支持该API，需要使用替代方案。

## 2. 解决方案概述

采用**适配器模式**，为不同浏览器提供统一的存储接口，根据浏览器类型自动选择合适的存储实现：

- **Chrome/Edge/Opera**：继续使用`File System Access API`
- **Firefox**：使用传统的`<input type="file">`和`<a download>`结合`localStorage`或`IndexedDB`
- **trea**：根据其实际支持情况选择合适的API

## 3. 具体代码修改方案

### 3.1 浏览器检测和存储适配器设计

```javascript
// 在NavigationModel类中添加

// 浏览器检测方法
isFirefox() {
    return navigator.userAgent.toLowerCase().includes('firefox');
}

isTreaBrowser() {
    return navigator.userAgent.toLowerCase().includes('trea');
}

// 存储适配器工厂方法
createStorageAdapter() {
    if (this.isFileSystemAPISupported()) {
        return new FileSystemAccessAdapter(this);
    } else if (this.isFirefox() || this.isTreaBrowser()) {
        return new FirefoxStorageAdapter(this);
    } else {
        return new LocalStorageAdapter(this);
    }
}
```

### 3.2 存储适配器基类

```javascript
// 存储适配器基类
class StorageAdapter {
    constructor(model) {
        this.model = model;
    }
    
    // 抽象方法，子类必须实现
    async openStorage() {}
    async saveStorage() {}
    async backupStorage() {}
    async restoreStorage() {}
}
```

### 3.3 Firefox存储适配器实现

```javascript
// Firefox存储适配器
class FirefoxStorageAdapter extends StorageAdapter {
    constructor(model) {
        super(model);
        this.fileInput = null;
        this.downloadLink = null;
    }
    
    // 初始化DOM元素
    initElements() {
        if (!this.fileInput) {
            this.fileInput = document.createElement('input');
            this.fileInput.type = 'file';
            this.fileInput.accept = '.json';
            this.fileInput.style.display = 'none';
            document.body.appendChild(this.fileInput);
        }
        
        if (!this.downloadLink) {
            this.downloadLink = document.createElement('a');
            this.downloadLink.style.display = 'none';
            document.body.appendChild(this.downloadLink);
        }
    }
    
    // 打开存储文件
    async openStorage() {
        this.initElements();
        
        return new Promise((resolve) => {
            this.fileInput.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const data = JSON.parse(event.target.result);
                            this.model.currentSettings = data;
                            this.model.ensureSettingsStructure();
                            this.model.saveSettings(); // 同时保存到localStorage
                            resolve(true);
                        } catch (err) {
                            console.error('读取文件失败:', err);
                            resolve(false);
                        }
                    };
                    reader.readAsText(file);
                } else {
                    resolve(false);
                }
            };
            
            this.fileInput.click();
        });
    }
    
    // 保存存储文件
    async saveStorage() {
        this.initElements();
        
        try {
            // 更新时间戳和校验和
            this.model.currentSettings.timestamp = Date.now();
            this.model.currentSettings.checksum = this.model.generateChecksum(this.model.currentSettings);
            
            const dataStr = JSON.stringify(this.model.currentSettings, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            
            // 使用<a download>方式下载文件
            const url = URL.createObjectURL(dataBlob);
            this.downloadLink.href = url;
            this.downloadLink.download = this.model.storageFileName;
            this.downloadLink.click();
            
            // 清理URL对象
            setTimeout(() => {
                URL.revokeObjectURL(url);
            }, 100);
            
            return true;
        } catch (err) {
            console.error('保存文件失败:', err);
            return false;
        }
    }
    
    // 备份存储文件
    async backupStorage() {
        this.initElements();
        
        try {
            const dataStr = JSON.stringify(this.model.currentSettings, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            
            // 使用<a download>方式下载备份文件
            const url = URL.createObjectURL(dataBlob);
            this.downloadLink.href = url;
            this.downloadLink.download = this.model.backupFileName;
            this.downloadLink.click();
            
            // 清理URL对象
            setTimeout(() => {
                URL.revokeObjectURL(url);
            }, 100);
            
            return true;
        } catch (err) {
            console.error('备份文件失败:', err);
            return false;
        }
    }
    
    // 恢复存储文件
    async restoreStorage() {
        return this.openStorage();
    }
}
```

### 3.4 修改NavigationModel类的方法

```javascript
// 修改NavigationModel类的方法

// 修改initFileStorage方法
async initFileStorage() {
    this.storageAdapter = this.createStorageAdapter();
    this.isFileStorageEnabled = true;
    return true;
}

// 修改openStorageFile方法
async openStorageFile() {
    return this.storageAdapter.openStorage();
}

// 修改saveToFile方法
async saveToFile() {
    return this.storageAdapter.saveStorage();
}

// 修改backupFile方法
async backupFile() {
    return this.storageAdapter.backupStorage();
}

// 修改restoreFromBackup方法
async restoreFromBackup() {
    return this.storageAdapter.restoreStorage();
}
```

### 3.5 错误处理和用户反馈

```javascript
// 在NavigationApp类中修改相关方法

toggleFileStorage(enabled) {
    if (enabled) {
        if (this.model.isFirefox() || this.model.isTreaBrowser()) {
            // 对于Firefox和trea浏览器，直接启用，不做API检测
            this.model.isFileStorageEnabled = true;
            this.showToast('文件存储已启用（使用浏览器兼容模式）');
        } else if (this.model.isFileSystemAPISupported()) {
            // 原有逻辑
            this.model.initFileStorage().then(success => {
                if (success) {
                    this.model.isFileStorageEnabled = true;
                    this.showToast('文件存储已启用');
                } else {
                    this.enableFileStorageCheckbox.checked = false;
                    this.showToast('文件存储初始化失败，请重试', 'error');
                }
            }).catch(err => {
                this.enableFileStorageCheckbox.checked = false;
                this.showToast('文件存储初始化失败：' + err.message, 'error');
            });
        } else {
            this.enableFileStorageCheckbox.checked = false;
            this.showToast('您的浏览器不支持文件系统访问API', 'error');
        }
    } else {
        this.model.isFileStorageEnabled = false;
        this.showToast('文件存储已禁用');
    }
}
```

## 4. 数据持久化策略

### 4.1 Firefox浏览器

1. **主要存储**：使用传统的文件下载/上传方式，用户可以手动选择保存位置
2. **临时存储**：结合`localStorage`或`IndexedDB`，确保数据不丢失
3. **自动备份**：定期将数据备份到浏览器存储中

### 4.2 trea浏览器

根据其实际支持情况选择：
- 如果支持`IndexedDB`：使用`IndexedDB`作为主要存储
- 如果支持文件API：使用类似Firefox的实现
- 否则：使用`localStorage`

## 5. 安全规范和存储限制

### 5.1 Firefox浏览器

- 遵循Firefox的安全策略，不请求额外的权限
- 使用HTTPS确保数据传输安全
- 限制文件大小，避免超出浏览器处理能力
- 提供清晰的用户提示，告知用户数据存储位置

### 5.2 trea浏览器

- 遵循trea浏览器的安全规范
- 确保数据加密存储
- 定期清理临时文件
- 提供数据导出/导入功能

## 6. 测试和验证

1. **功能测试**：验证在Firefox和trea浏览器中能够正常启用、保存和恢复设置
2. **兼容性测试**：确保修改后的代码在所有支持的浏览器中都能正常工作
3. **性能测试**：验证大数据量下的存储性能
4. **安全测试**：确保数据存储和传输的安全性

## 7. 预期效果

1. Firefox浏览器：能够通过传统的文件下载/上传方式实现本地文件存储功能
2. trea浏览器：根据其支持情况选择合适的存储实现
3. 保持与原有代码的兼容性
4. 提供统一的用户体验
5. 确保数据持久化和安全

该方案将使本地文件存储功能能够在Firefox和trea浏览器中稳定运行，同时保持良好的用户体验和数据安全性。